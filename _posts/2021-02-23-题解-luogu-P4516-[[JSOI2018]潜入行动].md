---
layout:     post                    # 使用的布局（不需要改）
title:      题解 luogu P4516 【[JSOI2018]潜入行动】               # 标题 
subtitle:   A really good question. #副标题
date:       2021-02-23              # 时间
author:     nomonick                        # 作者
header-img: img/starriver.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    -  luogu
    -  solution
---

# 解析

[luogu P4516 [JSOI2018]潜入行动](https://www.luogu.com.cn/problem/P4516)


这是一道树上背包的题目，确实很难想到思路

首先定义一个数组，用来存储状态

即：dp[u][i][0/1][0/1] ⟹  表示以 u 为根节点的子树，在放了 i 个监视器,保证全部的子树上点都被监视到的情况下，带点 u 上放与不放监视器，且是否被监视到。

在看出背包后，我们去寻找转移方程（这就是重难点），

现在假设，我们已将查询到了以 u 为根节点的树 k_1 ，此时发现了这个树的下方还有一个还有以 v 为根节点的子树 k_2，于是把这个子树就并在一起形成一个大的图以满足要求：

------

∀dp[u][i][0][0]

u 点没有被放置，且没有被监视到

所以 v 点处不能放监视器，这是肯定的，但是这并不影响 v 点被监视到

∴dp[u][i+j][0][0]=∑dp[u][i][0][0]×dp[v][j][0][1]

------

∀dp[u][i][0][1]


这种情况要分类讨论：

- u 一侧子树的状态为 dp[u][i][0][1]

这时候 $u$ 已经被监视了，所以在不在 $v$ 处放监视器，对于当前的结果没有任何影响，但是要保证每个点都被监视到，所以 v 点被监视到

－ u 一侧子树的状态为 dp[u][i][0][0]

这时候 u 还没被监视，所以在 v 处放监视器是不争的事实，同时要保证每个点都被监视到所以 v 点也必须被监视

∴dp[u][i+j][0][1]=∑(dp[u][i][0][1]×(dp[v][j][0][1]+dp[v][j][1][1])+dp[u][i][0][0]×dp[v][j][1][1])

------

∀dp[u][i][1][0]

u 没被监视但是放了监视器，所以 u 一侧子树的状态一定是 dp[u][i][1][0]，v 是否被监视无所谓，但是一定不能放装置

∴dp[u][i+j][1][0]=∑dp[u][i][1][0]×(dp[v][j][0][0]+dp[v][j][0][1])

------

∀dp[u][i][1][1]

这种情况也要分类讨论(直接　wuhu　起飞,~~giao~~)：

- u 一侧子树的状态为 dp[u][i][1][0]

所以我们需要 v 点上放监视器来监视 u ，同时 v 点没有必要被监视

- u 一侧子树的状态为 dp[u][i][1][１]

u 已经被 k_1 侧子树满足了，所以 v 来说可以随便的安排（Everything is OK.）

∴dp[u][i+j][1][1]=∑(dp[u][i][1][0]×(dp[v][j][1][0]+dp[v][j][1][1])+dp[u][i][1][1]∗(dp[v][j][0][0]+dp[v][j][0][1]+dp[v][j][1][0]+dp[v][j][1][1]))


------

综上所述:

dp[u][i+j][0][0]=∑dp[u][i][0][0]×dp[v][j][0][1]

dp[u][i+j][0][1]=∑(dp[u][i][0][1]×(dp[v][j][0][1]+dp[v][j][1][1])+dp[u][i][0][0]×dp[v][j][1][1])

dp[u][i+j][1][0]=∑dp[u][i][1][0]×(dp[v][j][0][0]+dp[v][j][0][1])

dp[u][i+j][1][1]=∑(dp[u][i][1][0]×(dp[v][j][1][0]+dp[v][j][1][1])+dp[u][i][1][1]∗(dp[v][j][0][0]+dp[v][j][0][1]+dp[v][j][1][0]+dp[v][j][1][1]))

# code

```cpp
#include <cmath>

#include <cstdio>

#include <vector>

#include <iostream>

#include <algorithm> // 万能头不是好习惯

using namespace std;

const int SIZE = 1e5 + 50;
const int NUM = 110;
const int mod = 1e9 + 7;

inline int read()
{
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		f = (ch == '-' ? -1 : 1);
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

#define int long long

int n,k,num_edge;
int head[SIZE],siz[SIZE];
int dp[SIZE][NUM][2][2],tmp[NUM][2][2];
struct node
{
	int to,nxt;
};
node edge[SIZE << 1];

inline void add(int u,int v)
{
	edge[++num_edge].to = v;
	edge[num_edge].nxt = head[u];
	head[u] = num_edge;
}

inline int solve(int u,long long v)
{
	if (v >= mod) v = v % mod;
	for (u += v; u >= mod; u -= mod);
	return u;
}

void dfs(int u,int fa)
{
	siz[u] = dp[u][0][0][0] = dp[u][1][1][0] = 1;
	for (int t = head[u]; t; t = edge[t].nxt)
	{
		int v = edge[t].to;
		if (v == fa) continue;
		dfs(v,u);
		int side = min(siz[u],k);
		for (int i = 0; i <= side; ++i)
		{
			tmp[i][0][0] = dp[u][i][0][0];
			dp[u][i][0][0] = 0;
			tmp[i][0][1] = dp[u][i][0][1];
			dp[u][i][0][1] = 0;
			tmp[i][1][0] = dp[u][i][1][0];
			dp[u][i][1][0] = 0;
			tmp[i][1][1] = dp[u][i][1][1];
			dp[u][i][1][1] = 0;
		}
		for (int i = 0; i <= side; ++i)
		{
			int limit = min(siz[v],k-i);
			for (int j = 0; j <= limit; ++j)
			{
				dp[u][i+j][0][0] = solve(dp[u][i+j][0][0],1ll * tmp[i][0][0] * dp[v][j][0][1]);
				dp[u][i+j][0][1] = solve(dp[u][i+j][0][1],1ll * tmp[i][0][1] * (dp[v][j][0][1] + dp[v][j][1][1]));
				dp[u][i+j][0][1] = solve(dp[u][i+j][0][1],1ll * tmp[i][0][0] * dp[v][j][1][1]);
				dp[u][i+j][1][0] = solve(dp[u][i+j][1][0],1ll * tmp[i][1][0] * (dp[v][j][0][0] + dp[v][j][0][1]));
				dp[u][i+j][1][1] = solve(dp[u][i+j][1][1],1ll * tmp[i][1][0] * (dp[v][j][1][0] + dp[v][j][1][1]));
				dp[u][i+j][1][1] = solve(dp[u][i+j][1][1],1ll * tmp[i][1][1] * (1ll * dp[v][j][0][0] + 1ll * dp[v][j][0][1] + 1ll * dp[v][j][1][0] + 1ll * dp[v][j][1][1]));
			}
		}
		siz[u] += siz[v];
	}
}

signed main()
{
	n = read();k = read();
	for (int i = 1; i < n; ++i)
	{
		int u = read(),v = read();
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	printf("%d\n",(dp[1][k][0][1] + dp[1][k][1][1]) % mod);
	return 0;
}

```
